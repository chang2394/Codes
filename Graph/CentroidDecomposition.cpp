/**
 * Problem: http://codeforces.com/contest/342/problem/E
 * Resource: https://threads-iiith.quora.com/Centroid-Decomposition-of-a-Tree
 * Complexity: Preprocess = O(NlogN), Query = O(NlogN^2) 
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author chang
 */


#include <cstdio>
#include <iostream>
#include <cassert>
#include <cctype>
#include <cfloat>
#include <climits>
#include <cstring>
#include <bitset>
#include <deque>
#include <map>
#include <set>
#include <stack>
#include <queue>
#include <vector>
#include <algorithm>
#include <string>

#include <cmath>
#include <fstream>
#include <iomanip>

using namespace std;

typedef vector<int> vi;


#define TRACE

#ifdef TRACE

template<class T, class U>
ostream &operator<<(ostream &out, const pair<T, U> &a) {
  out << "[" << a.first << " " << a.second << "]";
  return out;
}

template<class T>
ostream &operator<<(ostream &out, const vector<T> &a) {
  out << "[ ";
  for (auto &it : a)out << it << " ";
  out << "]";
  return out;
}

template<class T>
ostream &operator<<(ostream &out, const set<T> &a) {
  out << "[ ";
  for (auto &it : a)out << it << " ";
  out << "]";
  return out;
}

template<class T>
ostream &operator<<(ostream &out, const multiset<T> &a) {
  out << "[ ";
  for (auto &it : a)out << it << " ";
  out << "]";
  return out;
}

template<class T, class U>
ostream &operator<<(ostream &out, const map<T, U> &a) {
  for (auto &it : a)
    out << it.first << " -> " << it.second << " | ";
  return out;
}

template<class T, class U>
ostream &operator<<(ostream &out, const multimap<T, U> &a) {
  for (auto &it : a)
    out << it.first << " -> " << it.second << " | ";
  return out;
}

#else
#define trace(...)
#define tracea(a,n)
#define traceaa(a,n,m)
#endif

#define pb push_back

const int oo = numeric_limits<int>::max() / 2 - 10;

const int ND = 1e5 + 10;
const int MD = 20;

vi edges[ND];
int centroid_parent[ND];
int childs[ND];

int in_time[ND], out_time[ND];
int log_parent[MD][ND];
int depth[ND], timer = 0;

int min_distance[ND];

class XeniaAndTree {
public:
  // centroid decomposition util start
  int compute_size_subtree(int cur_node, int cur_parent) {
    int ans = 1;
    for (auto y: edges[cur_node]) {
      if (centroid_parent[y] != -1 or y == cur_parent) continue;
      ans += compute_size_subtree(y, cur_node);
    }
    childs[cur_node] = ans;
    return ans;
  }

  void decompose_tree(int cur_node, int cur_parent, int no_nodes, int prev_centroid) {
    for (auto y: edges[cur_node]) {
      if (y == cur_parent or centroid_parent[y] != -1) continue;
      if (2 * childs[y] > no_nodes) {
        decompose_tree(y, cur_node, no_nodes, prev_centroid);
        return;
      }
    }

    centroid_parent[cur_node] = prev_centroid;
    for (auto y: edges[cur_node]) {
      if (centroid_parent[y] != -1) continue;
      compute_size_subtree(y, -1);
      decompose_tree(y, -1, childs[y], cur_node);
    }
  }

  void init(int start) {
    memset(centroid_parent, -1, sizeof(centroid_parent));
    compute_size_subtree(start, -1);
    decompose_tree(start, -1, childs[start], -2);
  }

  // centroid decomposition util end

  bool is_parent(int x, int y) {
    return ((in_time[x] <= in_time[y]) and (out_time[x] >= out_time[y]));
  }

  void lca_precompute(int cur_node, int cur_parent, int cur_depth) {
    depth[cur_node] = cur_depth;
    in_time[cur_node] = timer++;
    log_parent[0][cur_node] = cur_parent;

    for (int h = 1; h < MD; ++h) {
      if (log_parent[h - 1][cur_node] == -1) break;
      log_parent[h][cur_node] = log_parent[h - 1][log_parent[h - 1][cur_node]];
    }

    for (auto y: edges[cur_node]) {
      if (y == cur_parent) continue;
      lca_precompute(y, cur_node, cur_depth + 1);
    }

    out_time[cur_node] = timer++;
  }

  int compute_lca(int x, int y) {
    if (is_parent(x, y))
      return x;

    int cur = x;
    for (int h = MD - 1; h >= 0; h--) {
      if (log_parent[h][cur] == -1) continue;
      int p = log_parent[h][cur];
      if (is_parent(p, y)) continue;
      cur = p;
    }

    return log_parent[0][cur];
  }

  int compute_dist(int x, int y) {
    int lca = compute_lca(x, y);
    int ans = depth[x] + depth[y] - 2 * depth[lca];
    return ans;
  }

  void paint_red(int cur_node, int red_node) {
    min_distance[cur_node] = min(min_distance[cur_node], compute_dist(cur_node, red_node));
    if (centroid_parent[cur_node] != -2)
      paint_red(centroid_parent[cur_node], red_node);
  }

  int get_closest(int cur_node, int query_node) {
    int cur_closest = min_distance[cur_node] + compute_dist(cur_node, query_node);
    if (centroid_parent[cur_node] == -2)
      return cur_closest;

    int parent_closest = get_closest(centroid_parent[cur_node], query_node);
    return min(cur_closest, parent_closest);
  }

  void solve(std::istream &in, std::ostream &out) {
    int n, m;
    in >> n >> m;

    memset(log_parent, -1, sizeof(log_parent));
    for (int i = 1; i < n; ++i) {
      int a, b;
      in >> a >> b;
      edges[a].pb(b);
      edges[b].pb(a);
    }

    int root = 1;
    init(root);

    lca_precompute(root, -1, 0);

    for (int i = 1; i <= n; ++i)
      min_distance[i] = oo;
    paint_red(1, 1);

    for (int i = 0; i < m; ++i) {
      int type, value;
      in >> type >> value;

      if (type == 1) paint_red(value, value);
      else {
        int ans = get_closest(value, value);
        out << ans << "\n";
      }
    }
  }
};


int main() {
  XeniaAndTree solver;
  std::istream &in(std::cin);
  std::ostream &out(std::cout);
  solver.solve(in, out);
  return 0;
}
