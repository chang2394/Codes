/*
    ***  AutoGenerated Header file ***
    * *  Created By : chang
    * *  Time Complexity : O(V+E)
    * *  Description : Code for finding articulation point  in a graph
    * *  Reference : "http://www.geeksforgeeks.org/articulation-points-or-cut-vertices-in-a-graph/"
    * *  Problem : http://lightoj.com/volume_showproblem.php?problem=1063 
*/

/**
 * @author chang
 * @date 17-01-2016
*/

#include <cstdio>
#include <iostream>
#include <cassert>
#include <cctype>
#include <cfloat>
#include <climits>
#include <cstring>
#include <bitset>
#include <deque>
#include <map>
#include <set>
#include <stack>
#include <queue>
#include <vector>
#include <algorithm>
#include <string>
#include <climits>
#include <cmath>

#define debug(a,n)   cerr << "["; for(int i = 0; i < n; ++i) cerr << a[i] << " ";cerr << "\b]\n";
#define dbg(args...) {debug1,args; cerr<<endl;}

#define each(v,c)  for(typeof((c).begin()) v = (c).begin(); v != (c).end(); ++v)
#define sync(x)    ios_base::sync_with_stdio(x)
#define pb         push_back
#define mp         make_pair
#define sz(a)      ((int)(a.size()))
#define all(a)     (a).begin(), (a).end()
#define fi         first
#define se         second
using namespace std;

struct debugger {
    template<typename T> debugger& operator , (const T& v) {
        cerr<<v<<" "; return *this;
    }
} debug1;

typedef long long LL;
typedef pair<int,int> pii;
typedef pair<int,pii> piii;
typedef vector<int> vi;
const int inf = 0x7fffffff;

const int ND = 11234;
const int ED = 41234;

int head[ND], nxt[ED], to[ED];
int low[ND], disc[ND];

bool visited[ND], ap[ND];
int nodes = 0, tym = 0;

void init(){
    nodes = tym = 0;
    memset(visited,false,sizeof(visited));
    memset(head,-1,sizeof(head));
    memset(ap,false,sizeof(ap));
}

void addEdge(int x,int y){
    to[nodes] = y, nxt[nodes] = head[x];
    head[x] = nodes++;
}

void dfs(int x,int f){
    low[x] = disc[x] = tym++;
    visited[x] = true;

    int childs = 0;
    for(int i = head[x]; i >= 0; i = nxt[i]){
        int y = to[i];

        if (!visited[y]){
            childs++;
            dfs(y,x);
            
            low[x] = min(low[x],low[y]);
            if (f != -1 && low[y] >= disc[x])
                ap[x] = true;
        } else if (y != f)
            low[x] = min(low[x],disc[y]);

    }

    if (f == -1 && childs > 1)
        ap[x] = true;
}

void solve(int tc){
    int n,m;
    scanf("%d%d",&n,&m);
    
    init();
    for(int i = 0; i < m; ++i){
        int x,y;
        scanf("%d%d",&x,&y);
        addEdge(x,y);
        addEdge(y,x);
    }

    for(int i = 1; i <= n; ++i){
        if (!visited[i]) dfs(i,-1);
    }

    int ans = 0;
    for(int i = 1; i <= n; ++i)
        ans += ap[i];

    printf("Case %d: %d\n",tc,ans);
}

int main()
{
    int tc;
    scanf("%d",&tc);
    for(int i = 1; i <= tc; ++i)
        solve(i);
    return 0;
}
